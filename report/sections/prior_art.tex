Our project is inspired heavily by ZooKeeper \cite{hunt_zookeeper_2010}. We based our service API design on 
ZooKeeper's, and aimed to replicate both its consistency guarantees and performance. In addition, we
borrowed the idea of a "znode" from ZooKeeper, which refers to a node in the tree structure the makes up
the state we expose to clients via our service API. Furthermore, we owe a great debt of gratitude to Dr.
Benjamin Reed for his advice and enthusiasm in the early stages of our project.

ZooKeeper achieves consensus through the ZooKeeper Atomic Broadcast (Zab)
protocol \cite{junqueira_zab_2011}, which is a leader-based atomic broadcast system designed to ensure
consistent state replication across nodes \cite{hunt_zookeeper_2010}. Zab shares some conceptual similarities
with the Raft algorithm \cite{ongaro_search_2014}, such as leader election and log replication, but was developed
independently. Since Raft has become widely adopted and is designed to be
understandable, we elected to use Raft to provide both leader election and
consistency in our implementation.

Much research has been done to improve the performance and consistency of Raft
under failure scenarios. For instance, Kim et al.~\ ite{kim_improved_2021} explored improving leader-based
consensus algorithms such as Raft using federated learning to enhance stability and
performance. Furthermore, Liu et al. \cite{liu_optimized_2022} has suggested improvements in both performance
and strict consistency guarantees over the original Raft algorithm by requiring strong
consistency of followers logs. They show that their accelerated log backtracking Raft
algorithm can reduce the number of RPCs required to resolve log conflicts under
multiple leader election failure scenarios. Similarly, Liu et al. \cite{liu_optimized_2023} propose an
optimized Raft algorithm (SS-Raft) that incorporates snapshot-based log compression
to reduce excessive log growth during replication and improve recovery under unreliable
networks and churn failures. We adopted a similar approach in the design of our log system
by creating a squash API to enable log compaction.

Finally, Paznikov et al.~\cite{paznikov_implementation_2020} proposes a leaderless approach
to atomic broadcast using the actor model of concurrency; while the actor model
approach is appealing to us, we think designing a ZooKeeper service around the actor
model is a more appropriate topic for subsequent research projects.
