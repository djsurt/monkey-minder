To validate linearizability, monotonic reads, cross-node consistency, and failure recovery,
we designed a set of test cases across 3 to 5 node clusers. Each test is described with its setup, actions, observations,
and expected results.

\todo[inline]{Adrian - maybe talk about testing library stuff here}

\todo[inline]{should say a little more about why these tests demonstrate these properties maybe}

\newcommand{\testitemSetup}{\item[] \hspace*{-4mm}\textbf{Setup:} }
\newcommand{\testitemExpect}{\item[] \hspace*{-4mm}\textbf{Expect:} }
\newcommand{\testitem}{\item}
\newcommand{\testitemClientaction}{\item[]}
\newcommand{\testFmtMessage}[4]{\(#1\rightarrow#2:\texttt{#3}\left(\text{\texttt{#4}}\right)\)}

\subsection{Sequential writes to leader}
\begin{itemize}
    \testitemSetup Create a three-node cluster, and start all nodes.
    \testitem Wait for a node (hereafter denoted as $L$) to be elected leader.
    \testitem Begin a client session $c$ to $L$.
    \begin{itemize}
        \testitemClientaction \testFmtMessage{c}{L}{Create}{/foo, "A"}
        \testitemClientaction \testFmtMessage{c}{L}{SetData}{/foo, "B", -1}
        \testitemClientaction \testFmtMessage{c}{L}{SetData}{/foo, "C", -1}
    \end{itemize}
    \testitemExpect Between each \codeterm{Create} / \codeterm{SetData}, $c$ reads \texttt{/foo}.
    Those reads should return \texttt{"A"}, then \texttt{"B"}, then \texttt{"C"}, in strict order.
\end{itemize}

% \subsection{Concurrent writes ordered by leader}
\subsection{Concurrent writes to leader}
\begin{itemize}
    \testitemSetup Create a three-node cluster, and start all nodes.\\
        Initialize field \texttt{/foo} to \texttt{"X"}.
    \testitem Wait for a node (hereafter denoted as $L$) to be elected leader.
    \testitem Begin client sessions $c_1$ and $c_2$ to $L$.\\
    Concurrently:
    \begin{itemize}
        \testitemClientaction \testFmtMessage{c_1}{L}{SetData}{/foo, "A", -1}
        \testitemClientaction \testFmtMessage{c_2}{L}{SetData}{/foo, "B", -1}
    \end{itemize}
    \testitemExpect After both clients are finished, all clients read the same value for \texttt{/foo}.
\end{itemize}

% \textbf{Expected Result:} All nodes converge on a single final value in the leader's chosen
% serialization order (either $A \rightarrow B$ or $B \rightarrow A$).
% No interleaving or non-linearizable outcomes.


% \begin{samepage}
\subsection{Monotonic Reads}
\begin{itemize}
    \testitemSetup Create a three-node cluster, and start all nodes.\\
        Initialize field \texttt{/m} to \texttt{"0"}.
    \testitem Wait for a node (hereafter denoted as $L$) to be elected leader.\\
        Denote one of the two remaining nodes as $F$.
    \testitem Begin a client session $c_L$ to $L$.
    \begin{itemize}
        \testitemClientaction \testFmtMessage{c_L}{L}{SetData}{/m, "1", -1}
        \testitemClientaction Wait for 2 seconds.
        \testitemClientaction \testFmtMessage{c_L}{L}{SetData}{/m, "2", -1}
    \end{itemize}
    \testitem Concurrently, begin a client session $c_F$ to $F$.
    \begin{itemize}
        \testitemClientaction Repeat \testFmtMessage{c_F}{F}{GetData}{/m}
    \end{itemize}
    \testitemExpect $c_F$ should never receive \texttt{"0"} after it has received one of \(\{\texttt{"1"}, \texttt{"2"}\}\).
    \testitemExpect $c_F$ should never receive \texttt{"1"} after it has received \texttt{"2"}.
    \testitemExpect $c_F$ should eventually receive \texttt{"2"}.
\end{itemize}
% \end{samepage}

% \subsubsection{Test 3: Read-Only Client Monotonicity}
%
% \textbf{Setup:} Client $C_3$ reads from $F$. Leader $L$ performs updates.
%
% \textbf{Actions:}
% $L$: \texttt{SetData("/m", "1")} then \texttt{SetData("/m", "2")}.
% $C_3$ polls \texttt{GetData("/m)} every 100ms.
%
% \textbf{Expected Result:} Observed values are monotonic: once $C_3$ sees ``2'', it never
% returns ``1'' again. Temporary lag is allowed but regressions are not.

% \subsubsection{Test 4: Monotonic Reads Across Session Migration}
% 
% \textbf{Setup:} Client $C_4$ initially connected to follower $F_1$. Migrates mid-run to $F_2$.
% 
% \textbf{Actions:}
% $L$: \texttt{SetData("/n", "x")} then \texttt{SetData("/n", "y")}.
% $C_4$ reads \texttt{GetData("/n")} from $F_1$, migrates, then continues reading on $F_2$.
% 
% \textbf{Expected Result:} No backwards reads: after observing ``y'' on $F_1$, reads on 
% $F_2$ never return ``x''. Followers must not serve older states than those already observed.

% TODO
% \subsection{Cross-Node Consistency}
% \subsubsection{Test 5: Writes on Leader, Reads on All Nodes}
% 
% \textbf{Setup:} Five-node cluster. Clients $C_1\dots C5$ connected to different nodes.
% 
% \textbf{Actions:} Leader performs:
% \begin{enumerate}
%     \item \texttt{Create("/k"),"alpha"}.
%     \item \texttt{SetData("/k", "beta")}
% \end{enumerate}
% 
% \textbf{Observation:} All clients repeatedly read \texttt{GetData("/k")} for 5 seconds.
% 
% \textbf{Expected Result:} All nodes converge to ``beta''. No node returns a value outside the committed sequence.
% Temporary follower lag is acceptable.

\subsection{Leader election initiated after leader death}
\begin{itemize}
    \testitemSetup Create a five-node cluster, and start all nodes.
    \testitem Wait for a node (hereafter denoted as $L_1$) to be elected leader.
    \testitem Kill $L_1$.
    \testitemExpect After some time has passed, leader election should occur, and a new leader $L_2$ should have been elected.
\end{itemize}

\subsection{Leader election requires majority}
\begin{itemize}
    \testitemSetup Create a five-node cluster, and start all nodes.
    \testitem Wait for a node (hereafter denoted as $L_1$) to be elected leader.
    \testitem Kill $L_1$.
    \testitemExpect After some time has passed, leader election should occur, and a new leader (denoted as $L_2$) should have been elected.
    \testitem Kill $L_2$.
    \testitemExpect After some time has passed, leader election should occur, and a new leader (denoted as $L_3$) should have been elected.
    \testitem Kill $L_3$.
    \testitemExpect No leader is elected.\\
        As a majority of nodes are not alive, it should be impossible for any remaining node to win an election.
    \testitem Restart $L_2$.
    \testitemExpect After some time has passed, leader election should occur, and a new leader should be elected.\\
        Now that there is once again a majority of nodes alive, leader election is able to proceed.
\end{itemize}

% \subsubsection{Failure Recovery}
% \subsubsection{Test 6: Leader Crash After Append, Before Commit}
% 
% \textbf{Setup:} Three-node cluster. Followers $F_1$, $F_2$.
% 
% \textbf{Actions:}
% Leader $L$ appends \texttt{SetData("/r", "new")} then crashes \emph{before} receiving a quorum ACK.
% 
% \textbf{Observation:} Reads on $F_1$ and $F_2$ via \texttt{GetData("/r)}.
% 
% \textbf{Expected Result:} Value remains the old value. The uncommitted write is discarded after new leader election. No 
% partial visibility.

% TODO
% \subsection{Quorum and Availability}
% \subsubsection{Test 7: Minority Partition Unavailable for Writes}
% 
% \textbf{Setup:} Five-node cluster partitioned into 3-node majority and 2-node minority.  
% 
% \textbf{Actions:} Clients attempt writes in both partitions.  
% 
% \textbf{Expected Result:}  
% \begin{itemize}
%   \item Majority partition continues serving writes normally.
%   \item Minority partition rejects or blocks writes.
%   \item Minority reads may lag or fail.
%   \item After healing, minority catches up from leader log.
% \end{itemize}

% TODO
% \subsubsection{Test 8: Node Join and Catch-Up}
% 
% \textbf{Setup:} Three nodes perform 100 sequential updates on \texttt{/z}.
% 
% \textbf{Actions:} Add new node $N_4$, allow it to synchronize.
% 
% \textbf{Expected Result:} After catch-up, $N_4$ returns the latest committed value.
% Log backfull converges without divergence.

% \subsection{Watches and Notifications}
% \subsubsection{Test 9: Watch Triggers on Immediate Children}
% AppendEntries Path (Follower \& Leader, \S5.3)
% \textbf{Setup:} Client registers a watch via \texttt{GetChildren("/p", watchChan)}.
% 
% \textbf{Actions:}
% Leader creates \texttt{/p/a}, then \texttt{/p/a/b}, then deletes \texttt{/p}.
% 
% \textbf{Expected Result:}
% Notifications fire for \texttt{/p/a} (child created) and \texttt{/p} (deleted).
% No notification for grandchild \texttt{/p/a/b}, consistent with ZooKeeper semantics.
